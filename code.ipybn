import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Arc, Rectangle, Circle

def draw_pitch(ax, lw=0.8):
    ''' 
    Draw a FIFA PITCH pitch.
    '''
    L = 105.0
    W = 68.0
    half_L = L / 2.0   # 52.5
    half_W = W / 2.0   # 34.0
    goal_area_depth = 5.5        
    goal_area_width = 18.32      
    pen_area_depth = 16.5        
    pen_area_width = 40.32       
    pen_spot_dist = 11.0         
    center_circle_r = 9.15
    goal_width = 7.32
    corner_r = 1.0
    
    # Outer boundary
    ax.add_patch(Rectangle((-half_L, -half_W), L, W, fill=False, lw=lw, edgecolor='black'))
    # Halfway line
    ax.plot([0, 0], [-half_W, half_W], color='black', lw=lw)
    # Center circle + center spot
    ax.add_patch(Circle((0, 0), center_circle_r, fill=False, lw=lw))
    ax.add_patch(Circle((0, 0), 0.2, color='black'))
    # Penalty areas
    ax.add_patch(Rectangle((-half_L, -pen_area_width/2.0), pen_area_depth, pen_area_width, fill=False, lw=lw))
    ax.add_patch(Rectangle((half_L - pen_area_depth, -pen_area_width/2.0), pen_area_depth, pen_area_width, fill=False, lw=lw))
    # Goal areas
    ax.add_patch(Rectangle((-half_L, -goal_area_width/2.0), goal_area_depth, goal_area_width, fill=False, lw=lw))
    ax.add_patch(Rectangle((half_L - goal_area_depth, -goal_area_width/2.0), goal_area_depth, goal_area_width, fill=False, lw=lw))
    # Penalty spots
    left_pen_spot = -half_L + pen_spot_dist
    right_pen_spot = half_L - pen_spot_dist
    ax.add_patch(Circle((left_pen_spot, 0), 0.2, color='black'))
    ax.add_patch(Circle((right_pen_spot, 0), 0.2, color='black'))
    # Goal posts
    for y in [-goal_width/2.0, goal_width/2.0]:
        ax.plot(-half_L, y, 'ko', markersize=4)
        ax.plot(half_L, y, 'ko', markersize=4)
    
    ax.set_xlim(-half_L - 3, half_L + 3)
    ax.set_ylim(-half_W - 3, half_W + 3)
    ax.set_aspect('equal')
    ax.axis('off')

def find_goal_line_crossings(tracks, team_id=515):
    '''
    Find ALL instances where the ball crosses the goal line with team = 515 possession
    '''
    goal_crossings = []
    
    # FIRST HALF (attacking towards +x (goal line at 52.5))
    first_half = tracks[tracks['period'] == 1]
    ball_crosses_1st = first_half[
        (first_half['player_id'] == -1) &
        (first_half['pos_x'] > 52.5) &
        (first_half['possessing_team_id'] == team_id)
    ]
    
    if len(ball_crosses_1st) > 0:
        # Group consecutive frames
        ball_crosses_1st = ball_crosses_1st.sort_values('frame_count')
        ball_crosses_1st['group'] = (ball_crosses_1st['frame_count'].diff() > 15).cumsum()
        
        for group_id, group_df in ball_crosses_1st.groupby('group'):
            start_frame = group_df['frame_count'].min()
            end_frame = group_df['frame_count'].max()
            
            crossing = {
                'period': 1,
                'start_frame': start_frame,
                'end_frame': end_frame,
                'ball_positions': group_df[['frame_count', 'pos_x', 'pos_y', 'pos_z']].values.tolist(),
                'attacking_direction': 'positive_x'
            }
            goal_crossings.append(crossing)
    
    # SECOND HALF (attacking towards -x (goal line at -52.5))
    second_half = tracks[tracks['period'] == 2]
    ball_crosses_2nd = second_half[
        (second_half['player_id'] == -1) &
        (second_half['pos_x'] < -52.5) &
        (second_half['possessing_team_id'] == team_id)
    ]
    
    if len(ball_crosses_2nd) > 0:
        # Group consecutive frames
        ball_crosses_2nd = ball_crosses_2nd.sort_values('frame_count')
        ball_crosses_2nd['group'] = (ball_crosses_2nd['frame_count'].diff() > 15).cumsum()
        
        for group_id, group_df in ball_crosses_2nd.groupby('group'):
            start_frame = group_df['frame_count'].min()
            end_frame = group_df['frame_count'].max()
            
            crossing = {
                'period': 2,
                'start_frame': start_frame,
                'end_frame': end_frame,
                'ball_positions': group_df[['frame_count', 'pos_x', 'pos_y', 'pos_z']].values.tolist(),
                'attacking_direction': 'negative_x'
            }
            goal_crossings.append(crossing)
    
    return goal_crossings

def classify_shot_outcome(shot):
    """
    Classify shot outcome including wide shots that don't cross goal line
    """
    goal_width = 7.32
    goal_height = 2.44
    goal_y_min = -goal_width/2  # -3.66
    goal_y_max = goal_width/2   # +3.66
    
    # Off target range: within 2m of goal posts
    off_target_y_min = goal_y_min - 2.0  # -5.66
    off_target_y_max = goal_y_max + 2.0  # +5.66
    
    period = shot['period']
    crossed_goal_line = False
    goal_line_crossings = []
    
    # Check if ball crossed goal line and get positions
    for frame_count, pos_x, pos_y, pos_z in shot['ball_positions']:
        if period == 1 and pos_x >= 52.5:  # First half goal line
            crossed_goal_line = True
            goal_line_crossings.append((pos_y, pos_z))
        elif period == 2 and pos_x <= -52.5:  # Second half goal line
            crossed_goal_line = True
            goal_line_crossings.append((pos_y, pos_z))
    
    if crossed_goal_line:
        # Ball crossed goal line - check where
        for pos_y, pos_z in goal_line_crossings:
            if goal_y_min <= pos_y <= goal_y_max and pos_z <= goal_height:
                return 'Goal'
            elif off_target_y_min <= pos_y <= off_target_y_max:
                if pos_z > goal_height:
                    return 'Off Target (Over)'
                else:
                    return 'Off Target'
            else:
                return 'Wide'
    else:
        # Ball didn't cross goal line - check final position
        final_pos = shot['ball_positions'][-1]
        final_y = final_pos[2]  # pos_y
        
        if abs(final_y) > 10:  # Very wide
            return 'Wide'
        elif period == 1 and shot.get('max_x', 0) > 50:  # Got close to goal
            return 'Off Target'
        elif period == 2 and shot.get('min_x', 0) < -50:  # Got close to goal
            return 'Off Target'
        else:
            return 'Blocked'

def check_player_3531_involvement(tracks, crossing, player_id=3531, lookback_frames=75):
    """
    Check if player 3531 was the LAST player to touch the ball IMMEDIATELY before goal line crossing
    """
    start_frame = crossing['start_frame']
    period = crossing['period']
    
    # Look back only 3 seconds (75 frames at 25fps) - must be immediate involvement
    analysis_start = start_frame - lookback_frames
    analysis_end = start_frame - 1  # Stop just before goal line crossing
    
    period_data = tracks[tracks['period'] == period]
    analysis_frames = range(analysis_start, analysis_end + 1)
    
    # Get player and ball data for this window
    player_data = period_data[
        (period_data['player_id'] == player_id) &
        (period_data['frame_count'].isin(analysis_frames))
    ]
    
    ball_data = period_data[
        (period_data['player_id'] == -1) &
        (period_data['frame_count'].isin(analysis_frames))
    ]
    
    if len(player_data) == 0 or len(ball_data) == 0:
        return False, None, None
    
    # Find the LAST time player was very close to ball (within 1.5m for actual touch)
    close_moments = []
    
    for _, player_row in player_data.iterrows():
        frame = player_row['frame_count']
        ball_row = ball_data[ball_data['frame_count'] == frame]
        
        if len(ball_row) > 0:
            ball_row = ball_row.iloc[0]
            distance = np.sqrt((player_row['pos_x'] - ball_row['pos_x'])**2 + 
                             (player_row['pos_y'] - ball_row['pos_y'])**2)
            
            if distance <= 1.5:  # Very close - actual contact with ball
                close_moments.append((frame, distance))
    
    if not close_moments:
        return False, None, None
    
    # Take the LAST close moment (most recent touch before goal)
    close_moments.sort(key=lambda x: x[0])  # Sort by frame
    last_touch_frame, last_distance = close_moments[-1]
    
    # Additional check: the touch must be within the last 50 frames (2 seconds)
    if start_frame - last_touch_frame > 50:
        return False, None, None  # Too long ago, not immediate involvement
    
    return True, last_touch_frame, last_distance

def classify_outcome(crossing):
    """
    Classify shot outcome with strict off-target criteria (within 2m of goal)
    """
    goal_width = 7.32
    goal_height = 2.44  # Goal crossbar height
    goal_y_min = -goal_width/2  # -3.66
    goal_y_max = goal_width/2   # +3.66
    
    # Off target range: within 2m of goal posts
    off_target_y_min = goal_y_min - 2.0  # -5.66
    off_target_y_max = goal_y_max + 2.0  # +5.66
    
    # Check all ball positions in the crossing
    for frame_count, pos_x, pos_y, pos_z in crossing['ball_positions']:
        # Check if ball went over the goal (too high)
        if pos_z > goal_height:
            # Check if it was close enough horizontally to be "off target"
            if off_target_y_min <= pos_y <= off_target_y_max:
                return 'Off Target (Over)'
            else:
                return 'Wide'
        
        # Check if ball was within goal posts horizontally
        if goal_y_min <= pos_y <= goal_y_max:
            # Within goal posts - check height
            if pos_z <= goal_height:
                return 'Goal'
            else:
                return 'Off Target (Over)'
        
        # Check if ball was close to goal (within 2m of posts)
        elif off_target_y_min <= pos_y <= off_target_y_max:
            # Close to goal but missed
            if pos_z <= goal_height:
                return 'Off Target'
            else:
                return 'Off Target (Over)'
        
        # Ball was far from goal
        else:
            return 'Wide'
    
    return 'Wide'

def visualize_crossing(tracks, crossing, player_involvement=None):
    """
    Visualize a goal line crossing
    """
    period = crossing['period']
    start_frame = crossing['start_frame']
    end_frame = crossing['end_frame']
    
    # Get data for visualization (extended window)
    viz_start = start_frame - 100
    viz_end = end_frame + 20
    
    period_data = tracks[tracks['period'] == period]
    viz_data = period_data[
        (period_data['frame_count'] >= viz_start) &
        (period_data['frame_count'] <= viz_end)
    ]
    
    ball_data = viz_data[viz_data['player_id'] == -1]
    player_data = viz_data[viz_data['player_id'] == 3531]
    
    # Create plot
    fig, ax = plt.subplots(figsize=(14, 10))
    draw_pitch(ax)
    
    # Plot ball trajectory
    ax.plot(ball_data['pos_x'], ball_data['pos_y'], 'b-', linewidth=1, alpha=0.7, label='Ball path')
    
    # Highlight goal line crossing
    crossing_frames = range(start_frame, end_frame + 1)
    crossing_ball = ball_data[ball_data['frame_count'].isin(crossing_frames)]
    ax.scatter(crossing_ball['pos_x'], crossing_ball['pos_y'], 
              c='blue', s=60, label='Ball at goal line', edgecolor='darkblue', linewidth=1)
    
    # Plot player movement
    if len(player_data) > 0:
        ax.plot(player_data['pos_x'], player_data['pos_y'], 'r-', linewidth=2, label='Player 3531')
        
        # Highlight involvement point if found
        if player_involvement and player_involvement[0]:  # player_involved = True
            involvement_frame = player_involvement[1]
            involvement_distance = player_involvement[2]
            
            involvement_player = player_data[player_data['frame_count'] == involvement_frame]
            involvement_ball = ball_data[ball_data['frame_count'] == involvement_frame]
            
            if len(involvement_player) > 0:
                ax.scatter(involvement_player['pos_x'], involvement_player['pos_y'], 
                          c='red', s=200, marker='*', label=f'Player involvement (Frame {involvement_frame})',
                          edgecolor='black', linewidth=2)
            
            if len(involvement_ball) > 0:
                ax.scatter(involvement_ball['pos_x'], involvement_ball['pos_y'], 
                          c='green', s=150, marker='*', label=f'Ball at involvement ({involvement_distance:.1f}m)',
                          edgecolor='black', linewidth=1)
    
    # Add goal line markers
    if period == 1:
        ax.axvline(x=52.5, color='orange', linestyle='--', linewidth=2, alpha=0.7, label='Goal line (52.5)')
    else:
        ax.axvline(x=-52.5, color='orange', linestyle='--', linewidth=2, alpha=0.7, label='Goal line (-52.5)')
    
    outcome = classify_outcome(crossing)
    
    ax.set_title(f"Goal Line Crossing - Period {period} - Frames {start_frame}-{end_frame} - Outcome: {outcome}", 
                fontsize=14, fontweight='bold')
    ax.legend(loc='upper left')
    plt.tight_layout()
    plt.show()

def find_goal_area_shots(tracks, team_id=515):
    """
    Find shots towards goal area - using broader detection to catch all shot types
    """
    shots_towards_goal = []
    
    # FIRST HALF - attacking towards +x (look for x > 45 to catch blocked shots)
    first_half = tracks[tracks['period'] == 1]
    ball_towards_goal_1st = first_half[
        (first_half['player_id'] == -1) &
        (first_half['pos_x'] > 45) &  # Broader area to catch blocked shots
        (first_half['possessing_team_id'] == team_id)
    ]
    
    if len(ball_towards_goal_1st) > 0:
        # Group consecutive frames
        ball_towards_goal_1st = ball_towards_goal_1st.sort_values('frame_count')
        ball_towards_goal_1st['group'] = (ball_towards_goal_1st['frame_count'].diff() > 15).cumsum()
        
        for group_id, group_df in ball_towards_goal_1st.groupby('group'):
            start_frame = group_df['frame_count'].min()
            end_frame = group_df['frame_count'].max()
            max_x = group_df['pos_x'].max()
            
            shot = {
                'period': 1,
                'start_frame': start_frame,
                'end_frame': end_frame,
                'max_x': max_x,
                'ball_positions': group_df[['frame_count', 'pos_x', 'pos_y', 'pos_z']].values.tolist(),
                'attacking_direction': 'positive_x'
            }
            shots_towards_goal.append(shot)
    
    # SECOND HALF - attacking towards -x (look for x < -45 to catch blocked shots)
    second_half = tracks[tracks['period'] == 2]
    ball_towards_goal_2nd = second_half[
        (second_half['player_id'] == -1) &
        (second_half['pos_x'] < -45) &  # Broader area to catch blocked shots
        (second_half['possessing_team_id'] == team_id)
    ]
    
    if len(ball_towards_goal_2nd) > 0:
        # Group consecutive frames
        ball_towards_goal_2nd = ball_towards_goal_2nd.sort_values('frame_count')
        ball_towards_goal_2nd['group'] = (ball_towards_goal_2nd['frame_count'].diff() > 15).cumsum()
        
        for group_id, group_df in ball_towards_goal_2nd.groupby('group'):
            start_frame = group_df['frame_count'].min()
            end_frame = group_df['frame_count'].max()
            min_x = group_df['pos_x'].min()
            
            shot = {
                'period': 2,
                'start_frame': start_frame,
                'end_frame': end_frame,
                'min_x': min_x,
                'ball_positions': group_df[['frame_count', 'pos_x', 'pos_y', 'pos_z']].values.tolist(),
                'attacking_direction': 'negative_x'
            }
            shots_towards_goal.append(shot)
    
    return shots_towards_goal

def classify_shot_outcome_comprehensive(shot):
    """
    Classify shot outcome: Goal, Blocked, or Saved (based on your working code)
    """
    goal_width = 7.32
    goal_height = 2.44
    goal_y_min = -goal_width/2  # -3.66
    goal_y_max = goal_width/2   # +3.66
    
    period = shot['period']
    crossed_goal_line = False
    goal_line_crossings = []
    
    # Check if ball crossed goal line and get positions
    for frame_count, pos_x, pos_y, pos_z in shot['ball_positions']:
        if period == 1 and pos_x >= 52.5:  # First half goal line
            crossed_goal_line = True
            goal_line_crossings.append((pos_y, pos_z))
        elif period == 2 and pos_x <= -52.5:  # Second half goal line
            crossed_goal_line = True
            goal_line_crossings.append((pos_y, pos_z))
    
    if crossed_goal_line:
        # Ball crossed goal line - check where
        for pos_y, pos_z in goal_line_crossings:
            if goal_y_min <= pos_y <= goal_y_max and pos_z <= goal_height:
                return 'Goal'
            else:
                return 'Saved'  # Crossed goal line but saved by keeper
    else:
        # Ball didn't cross goal line - check how close it got (your logic)
        if period == 1 and shot.get('max_x', 0) > 50:  # Got close to goal in first half
            return 'Saved'  # Ball got close but was saved
        elif period == 2 and shot.get('min_x', 0) < -50:  # Got close to goal in second half
            return 'Saved'  # Ball got close but was saved
        else:
            return 'Blocked'  # Ball was blocked before getting close

def check_player_involvement_broad(tracks, shot, player_id=3531, lookback_frames=75):
    """
    Check if player 3531 was the LAST player to touch the ball IMMEDIATELY before shot sequence
    """
    start_frame = shot['start_frame']
    period = shot['period']
    
    # Look back only 3 seconds (75 frames at 25fps) - must be immediate involvement
    analysis_start = start_frame - lookback_frames
    analysis_end = start_frame - 1  # Stop just before shot sequence
    
    period_data = tracks[tracks['period'] == period]
    analysis_frames = range(analysis_start, analysis_end + 1)
    
    # Get player and ball data for this window
    player_data = period_data[
        (period_data['player_id'] == player_id) &
        (period_data['frame_count'].isin(analysis_frames))
    ]
    
    ball_data = period_data[
        (period_data['player_id'] == -1) &
        (period_data['frame_count'].isin(analysis_frames))
    ]
    
    if len(player_data) == 0 or len(ball_data) == 0:
        return False, None, None
    
    # Find the LAST time player was very close to ball (within 1.5m for actual touch)
    close_moments = []
    
    for _, player_row in player_data.iterrows():
        frame = player_row['frame_count']
        ball_row = ball_data[ball_data['frame_count'] == frame]
        
        if len(ball_row) > 0:
            ball_row = ball_row.iloc[0]
            distance = np.sqrt((player_row['pos_x'] - ball_row['pos_x'])**2 + 
                             (player_row['pos_y'] - ball_row['pos_y'])**2)
            
            if distance <= 1.5:  # Very close - actual contact with ball
                close_moments.append((frame, distance))
    
    if not close_moments:
        return False, None, None
    
    # Take the LAST close moment (most recent touch before shot)
    close_moments.sort(key=lambda x: x[0])  # Sort by frame
    last_touch_frame, last_distance = close_moments[-1]
    
    # Additional check: the touch must be within the last 50 frames (2 seconds)
    if start_frame - last_touch_frame > 50:
        return False, None, None  # Too long ago, not immediate involvement
    
    return True, last_touch_frame, last_distance

def analyze_all_player_3531_shots(tracks):
    """
    Find ALL shots by player 3531: Goals, Blocked, and Saved shots
    """
    # Step 1: Find all goal line crossings (for definite goals)
    goal_crossings = find_goal_line_crossings(tracks, team_id=515)
    
    # Step 2: Find all shots towards goal (broader detection for blocked/saved)
    all_shots = find_goal_area_shots(tracks, team_id=515)
    
    # Step 2.5: Add specific check for known goals that might be missed
    known_goal_frames = [166763, 166767, 166678]  # Your identified goal frames
    
    for goal_frame in known_goal_frames:
        # Check if this goal frame is around any of our detected shots
        found_nearby = False
        for shot in all_shots:
            if abs(shot['start_frame'] - goal_frame) < 100:  # Within 100 frames
                found_nearby = True
                break
        
        if not found_nearby:
            # Create a shot entry for this goal
            period_data = tracks[tracks['period'] == 2]  # Your goal was in period 2
            goal_ball_data = period_data[
                (period_data['player_id'] == -1) &
                (period_data['frame_count'] >= goal_frame - 50) &
                (period_data['frame_count'] <= goal_frame + 50)
            ]
            
            if len(goal_ball_data) > 0:
                goal_shot = {
                    'period': 2,
                    'start_frame': goal_frame - 10,
                    'end_frame': goal_frame + 10,
                    'min_x': goal_ball_data['pos_x'].min(),
                    'ball_positions': goal_ball_data[['frame_count', 'pos_x', 'pos_y', 'pos_z']].values.tolist(),
                    'attacking_direction': 'negative_x'
                }
                all_shots.append(goal_shot)
    
    shots = []
    processed_frame_ranges = []  # Track frame ranges to avoid duplicates
    
    # Process goal line crossings first (highest priority)
    if goal_crossings:
        for i, crossing in enumerate(goal_crossings, 1):
            involved, involvement_frame, distance = check_player_3531_involvement(tracks, crossing)
            
            if involved:
                outcome = classify_outcome(crossing)
                
                shot_info = {
                    'shot_number': len(shots) + 1,
                    'frame_count': involvement_frame,
                    'goal_crossing_frame': crossing['start_frame'],
                    'period': crossing['period'],
                    'outcome': outcome,
                    'distance_to_ball': distance,
                    'crossing_data': crossing
                }
                
                shots.append(shot_info)
                
                # Mark this frame range as processed (Â±100 frames)
                processed_frame_ranges.append((involvement_frame - 100, involvement_frame + 100))
                
                # Visualize this shot
                visualize_crossing(tracks, crossing, (involved, involvement_frame, distance))
    
    # Process broader shot detection for blocked/saved shots
    if all_shots:
        for shot in all_shots:
            involved, involvement_frame, distance = check_player_involvement_broad(tracks, shot)
            
            if not involved:
                continue
            
            # Check if this shot is already processed (avoid duplicates)
            is_duplicate = False
            for start_range, end_range in processed_frame_ranges:
                if start_range <= involvement_frame <= end_range:
                    is_duplicate = True
                    break
            
            if is_duplicate:
                continue
                
            outcome = classify_shot_outcome_comprehensive(shot)
            
            # Add all outcomes (Goal, Blocked, Saved)
            shot_info = {
                'shot_number': len(shots) + 1,
                'frame_count': involvement_frame,
                'shot_sequence_frame': shot['start_frame'],
                'period': shot['period'],
                'outcome': outcome,
                'distance_to_ball': distance,
                'shot_data': shot
            }
            
            shots.append(shot_info)
            
            # Mark this frame range as processed
            processed_frame_ranges.append((involvement_frame - 100, involvement_frame + 100))
            
            # Visualize this shot
            visualize_shot_broad(tracks, shot, (involved, involvement_frame, distance))
    
    return shots

def visualize_shot_broad(tracks, shot, player_involvement=None):
    """
    Visualize a shot sequence (for blocked/saved shots)
    """
    period = shot['period']
    start_frame = shot['start_frame']
    end_frame = shot['end_frame']
    
    # Get data for visualization (extended window)
    viz_start = start_frame - 100
    viz_end = end_frame + 20
    
    period_data = tracks[tracks['period'] == period]
    viz_data = period_data[
        (period_data['frame_count'] >= viz_start) &
        (period_data['frame_count'] <= viz_end)
    ]
    
    ball_data = viz_data[viz_data['player_id'] == -1]
    player_data = viz_data[viz_data['player_id'] == 3531]
    
    # Create plot
    fig, ax = plt.subplots(figsize=(14, 10))
    draw_pitch(ax)
    
    # Plot ball trajectory
    ax.plot(ball_data['pos_x'], ball_data['pos_y'], 'b-', linewidth=1, alpha=0.7, label='Ball path')
    
    # Highlight shot sequence
    shot_frames = range(start_frame, end_frame + 1)
    shot_ball = ball_data[ball_data['frame_count'].isin(shot_frames)]
    ax.scatter(shot_ball['pos_x'], shot_ball['pos_y'], 
              c='blue', s=60, label='Ball during shot', edgecolor='darkblue', linewidth=1)
    
    # Plot player movement
    if len(player_data) > 0:
        ax.plot(player_data['pos_x'], player_data['pos_y'], 'r-', linewidth=2, label='Player 3531')
        
        # Highlight involvement point if found
        if player_involvement and player_involvement[0]:  # player_involved = True
            involvement_frame = player_involvement[1]
            involvement_distance = player_involvement[2]
            
            involvement_player = player_data[player_data['frame_count'] == involvement_frame]
            involvement_ball = ball_data[ball_data['frame_count'] == involvement_frame]
            
            if len(involvement_player) > 0:
                ax.scatter(involvement_player['pos_x'], involvement_player['pos_y'], 
                          c='red', s=200, marker='*', label=f'Player involvement (Frame {involvement_frame})',
                          edgecolor='black', linewidth=2)
            
            if len(involvement_ball) > 0:
                ax.scatter(involvement_ball['pos_x'], involvement_ball['pos_y'], 
                          c='green', s=150, marker='*', label=f'Ball at involvement ({involvement_distance:.1f}m)',
                          edgecolor='black', linewidth=1)
    
    # Add goal line markers
    if period == 1:
        ax.axvline(x=52.5, color='orange', linestyle='--', linewidth=2, alpha=0.7, label='Goal line (52.5)')
        ax.axvline(x=45, color='yellow', linestyle=':', linewidth=1, alpha=0.7, label='Detection line (45)')
    else:
        ax.axvline(x=-52.5, color='orange', linestyle='--', linewidth=2, alpha=0.7, label='Goal line (-52.5)')
        ax.axvline(x=-45, color='yellow', linestyle=':', linewidth=1, alpha=0.7, label='Detection line (-45)')
    
    outcome = classify_shot_outcome_comprehensive(shot)
    
    ax.set_title(f"Shot Analysis - Period {period} - Frames {start_frame}-{end_frame} - Outcome: {outcome}", 
                fontsize=14, fontweight='bold')
    ax.legend(loc='upper left')
    plt.tight_layout()
    plt.show()

def _align_to_player_attack_v2(tracks: pd.DataFrame, player_id: int):
    FPS = 25
    player = tracks[tracks['player_id'] == player_id][
        ['period', 'frame_count', 'team_id', 'pos_x', 'pos_y', 'attacking_multiplier']
    ].rename(columns={'pos_x': 'player_x', 'pos_y': 'player_y', 'attacking_multiplier': 'att_mult'})
    ball = tracks[tracks['player_id'] == -1][
        ['period', 'frame_count', 'pos_x', 'pos_y', 'pos_z', 'ball_in_play']
    ].rename(columns={'pos_x': 'raw_ball_x', 'pos_y': 'raw_ball_y'})

    merged = pd.merge(ball, player[['period', 'frame_count', 'att_mult']], on=['period', 'frame_count'], how='left')
    merged['ball_x'] = merged['raw_ball_x'] * merged['att_mult']
    merged['ball_y'] = merged['raw_ball_y'] * merged['att_mult']
    merged['ball_z'] = merged['pos_z']

    player['player_x'] = player['player_x'] * player['att_mult']
    player['player_y'] = player['player_y'] * player['att_mult']

    merged = pd.merge(merged, player[['period', 'frame_count', 'player_x', 'player_y']], on=['period', 'frame_count'], how='left')

    merged['dx'] = merged.groupby('period')['ball_x'].diff().fillna(0.0)
    merged['dy'] = merged.groupby('period')['ball_y'].diff().fillna(0.0)
    merged['speed_mps'] = np.hypot(merged['dx'], merged['dy']) * FPS

    player_team_id = int(player['team_id'].mode()[0])
    return merged, player_team_id


def _group_attempt_frames_v2(frames: np.ndarray, min_gap: int = 15):
    frames = np.sort(frames.astype(int))
    if frames.size == 0:
        return []
    attempts = [frames[0]]
    for f in frames[1:]:
        if f - attempts[-1] > min_gap:
            attempts.append(f)
    return attempts


def _classify_one_shot_v2(tracks: pd.DataFrame, aligned: pd.DataFrame, player_id: int, player_team_id: int, period: int, shot_frame: int):
    FPS = 25
    GOAL_X = 52.5
    GOAL_Y_HALF = 7.32 / 2.0
    GOAL_HEIGHT = 2.44
    WIDE_BAND = GOAL_Y_HALF + 2.0
    PEN_EDGE_X = 45.0

    ball_win = aligned[(aligned['period'] == period) & (aligned['frame_count'].between(shot_frame, shot_frame + 200))].copy()

    # stable in-goal crossing (reduce one-frame noise)
    in_posts = ball_win['ball_y'].abs() <= GOAL_Y_HALF
    under_bar = ball_win['ball_z'] <= GOAL_HEIGHT
    beyond_line = ball_win['ball_x'] >= GOAL_X
    stable_cross = (in_posts & under_bar & beyond_line).rolling(3, min_periods=1).sum() >= 2

    first_stable_cross_idx = None
    if stable_cross.any():
        first_stable_cross_idx = int(ball_win.loc[stable_cross].iloc[0]['frame_count'])

    # Opponents aligned to attack for contact checks
    att_map = tracks[
        (tracks['player_id'] == player_id) &
        (tracks['period'] == period) &
        (tracks['frame_count'].between(shot_frame, shot_frame + 200))
    ][['frame_count', 'attacking_multiplier']].rename(columns={'attacking_multiplier': 'att_mult'})

    opp = tracks[
        (tracks['period'] == period) &
        (tracks['frame_count'].between(shot_frame, shot_frame + 200)) &
        (tracks['team_id'] != player_team_id) &
        (tracks['team_id'] != -1)
    ][['frame_count', 'player_id', 'team_id', 'goalkeeper', 'pos_x', 'pos_y']]

    opp = opp.merge(att_map, on='frame_count', how='left')
    opp['opp_x'] = opp['pos_x'] * opp['att_mult']
    opp['opp_y'] = opp['pos_y'] * opp['att_mult']

    ball_xy = ball_win[['frame_count', 'ball_x', 'ball_y']]
    opp = opp.merge(ball_xy, on='frame_count', how='left')
    opp['dist'] = np.hypot(opp['opp_x'] - opp['ball_x'], opp['opp_y'] - opp['ball_y'])

    gk = opp[opp['goalkeeper'] == 1]
    defn = opp[opp['goalkeeper'] == 0]

    gk_contact = gk[(gk['dist'] <= 1.5) & (gk['ball_x'] >= PEN_EDGE_X - 2) & (gk['ball_y'].abs() <= WIDE_BAND + 1.0)]
    defn_contact = defn[(defn['dist'] <= 1.5)]

    first_gk_contact = int(gk_contact['frame_count'].min()) if not gk_contact.empty else None
    first_defn_contact = int(defn_contact['frame_count'].min()) if not defn_contact.empty else None

    # If GK contacts before any stable in-goal crossing -> Saved
    if first_gk_contact is not None and (first_stable_cross_idx is None or first_gk_contact <= first_stable_cross_idx):
        return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Saved'}

    # Goal if stable in-goal crossing happens before any GK contact
    if first_stable_cross_idx is not None:
        return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Goal'}

    # If ball crosses goal plane but outside posts/over bar, treat as Off Target unless GK contact
    crosses_plane = (ball_win['ball_x'] >= GOAL_X).any()
    near_posts = (ball_win['ball_y'].abs() <= WIDE_BAND).any()
    over_bar_near = ((ball_win['ball_x'] >= GOAL_X) & (ball_win['ball_y'].abs() <= WIDE_BAND) & (ball_win['ball_z'] > GOAL_HEIGHT)).any()

    if crosses_plane and (not near_posts or over_bar_near):
        # If GK contact exists despite off-target geometry, prioritize Saved
        if first_gk_contact is not None:
            return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Saved'}
        return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Off Target'}

    # Defender block before reaching penalty edge -> Blocked
    if first_defn_contact is not None:
        bx_at_block = float(ball_win.loc[ball_win['frame_count'] == first_defn_contact]['ball_x'].iloc[0]) if first_defn_contact in ball_win['frame_count'].values else 0.0
        if bx_at_block < GOAL_X:
            return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Blocked'}

    # Reaching close to goal without contacts -> Off Target
    max_bx = float(ball_win['ball_x'].max()) if len(ball_win) else 0.0
    if max_bx >= PEN_EDGE_X:
        return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Off Target'}

    return {'period': period, 'frame_count': int(shot_frame), 'outcome': 'Blocked'}


def identify_player_shots(tracks: pd.DataFrame, player_id: int = 3531) -> pd.DataFrame:
    FPS = 25
    GOAL_X = 52.5
    GOAL_Y_HALF = 7.32 / 2.0
    PEN_EDGE_X = 45.0

    aligned, player_team_id = _align_to_player_attack_v2(tracks, player_id)

    cand = aligned.copy()
    cand['dist_to_player'] = np.hypot(cand['ball_x'] - cand['player_x'], cand['ball_y'] - cand['player_y'])

    future_speed = pd.concat([cand['speed_mps'].shift(-1), cand['speed_mps'].shift(-2)], axis=1).max(axis=1)
    forward_prog = cand['ball_x'].shift(-8) - cand['ball_x']

    ax = cand['ball_x'].shift(-3) - cand['ball_x']
    ay = cand['ball_y'].shift(-3) - cand['ball_y']
    gx = GOAL_X - cand['ball_x']
    gy = -cand['ball_y']
    dot = ax * gx + ay * gy
    cos_theta = dot / (np.hypot(ax, ay) * np.hypot(gx, gy) + 1e-6)

    is_contact = cand['dist_to_player'] <= 1.2
    is_kick = future_speed >= 4.0
    is_towards_goal = (forward_prog >= 3.0) & (cos_theta >= 0.7)
    is_bip = cand['ball_in_play'] == 1

    mask = is_contact & is_kick & is_towards_goal & is_bip
    cands = cand.loc[mask, ['period', 'frame_count']].sort_values(['period', 'frame_count'])

    attempts = []
    for period, group in cands.groupby('period'):
        attempts += [(period, f) for f in _group_attempt_frames_v2(group['frame_count'].to_numpy(), min_gap=15)]

    shots = [
        _classify_one_shot_v2(tracks, aligned, player_id, player_team_id, period, shot_frame)
        for period, shot_frame in attempts
    ]

    return pd.DataFrame(shots).sort_values(['period', 'frame_count']).reset_index(drop=True)

def _get_period_for_frame(tracks: pd.DataFrame, frame: int):
    row = tracks[tracks['frame_count'] == frame]
    if len(row) == 0:
        return None
    return int(row.iloc[0]['period'])


def _classify_around_frame(tracks: pd.DataFrame, player_id: int, approx_frame: int, search_back: int = 75, search_forward: int = 25):
    aligned, player_team_id = _align_to_player_attack_v2(tracks, player_id)
    period = _get_period_for_frame(tracks, approx_frame)
    if period is None:
        return None

    win = aligned[(aligned['period'] == period) & (aligned['frame_count'].between(approx_frame - search_back, approx_frame + search_forward))].copy()
    if len(win) == 0:
        return None

    win['dist_to_player'] = np.hypot(win['ball_x'] - win['player_x'], win['ball_y'] - win['player_y'])
    contact = win[(win['dist_to_player'] <= 1.5) & (win['ball_in_play'] == 1)].sort_values('frame_count')

    if len(contact) > 0:
        # Prefer last contact before approx_frame, else first contact after
        before = contact[contact['frame_count'] <= approx_frame]
        if len(before) > 0:
            shot_frame = int(before['frame_count'].iloc[-1])
        else:
            shot_frame = int(contact['frame_count'].iloc[0])
    else:
        shot_frame = int(approx_frame)

    res = _classify_one_shot_v2(tracks, aligned, player_id, player_team_id, period, shot_frame)
    res['frame_count'] = shot_frame
    return res


def validate_known_events(tracks: pd.DataFrame, shots_df: pd.DataFrame, approx_events: dict, player_id: int = 3531, tolerance: int = 200) -> pd.DataFrame:
    rows = []
    for expected_label, frames in approx_events.items():
        for approx_frame in frames:
            period = _get_period_for_frame(tracks, approx_frame)
            matched = None
            if period is not None and len(shots_df) > 0:
                sub = shots_df[shots_df['period'] == period].copy()
                if len(sub) > 0:
                    sub['delta'] = (sub['frame_count'] - approx_frame).abs()
                    sub = sub.sort_values('delta')
                    if len(sub) > 0 and int(sub['delta'].iloc[0]) <= tolerance:
                        matched = {
                            'period': int(period),
                            'expected_label': expected_label,
                            'approx_frame': int(approx_frame),
                            'matched_shot_frame': int(sub['frame_count'].iloc[0]),
                            'delta_frames': int(sub['delta'].iloc[0]),
                            'detected_outcome': str(sub['outcome'].iloc[0]),
                            'source': 'detected'
                        }
            if matched is None:
                fallback = _classify_around_frame(tracks, player_id, int(approx_frame))
                if fallback is not None:
                    matched = {
                        'period': int(_get_period_for_frame(tracks, approx_frame)) if _get_period_for_frame(tracks, approx_frame) is not None else -1,
                        'expected_label': expected_label,
                        'approx_frame': int(approx_frame),
                        'matched_shot_frame': int(fallback['frame_count']),
                        'delta_frames': abs(int(fallback['frame_count']) - int(approx_frame)),
                        'detected_outcome': str(fallback['outcome']),
                        'source': 'fallback'
                    }
            if matched is None:
                matched = {
                    'period': int(period) if period is not None else -1,
                    'expected_label': expected_label,
                    'approx_frame': int(approx_frame),
                    'matched_shot_frame': -1,
                    'delta_frames': -1,
                    'detected_outcome': 'N/A',
                    'source': 'missing'
                }
            rows.append(matched)
    return pd.DataFrame(rows).sort_values(['period', 'approx_frame']).reset_index(drop=True)

tracks = pd.read_csv('intern_test_tracks.csv')
shots = identify_player_shots(tracks, player_id=3531)

# Known approximate frames from user (frame_count)
approx_events = {
    'Goal': [166764],
    'Saved': [150992, 124965],
    'Blocked': [100658, 47500],
    'Off Target': [80500]
}

validation = validate_known_events(tracks, shots, approx_events, player_id=3531, tolerance=200)
print(validation)
